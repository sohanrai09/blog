[{"id":0,"href":"/blog/posts/robotframework-3/","title":"Robotframework 3","section":"Posts","content":"In this blog post I\u0026rsquo;ll be going through a Test Scenario which involves multiple Test Cases with some interesting checks. I will be covering only the new things I\u0026rsquo;ve added for this Test Scenario when compared to my earlier posts, which can be found here. Test Suite begins by validating the network status on a particular device, this involves checking protocols such as OSPF, BGP, Interface Status etc. After ensuring network is in steady state, a configuration change is executed and after the change, network is validated again to ensure there has been no network impact.\nVariables # I will be using a yaml file to input the variables, this becomes convenient as we can extract data from yaml as lists, dicts etc.\n--- device: ip: \u0026#39;66.129.234.213\u0026#39; user: \u0026#39;robot\u0026#39; pwd: \u0026#39;robot123\u0026#39; port: \u0026#39;49003\u0026#39; interface: up_count: 48 ospf: nbr_full: 3 bgp: peers_up: 1 system_alarms: active_count: 2 configure: intf1: name: \u0026#39;ge-0/0/4\u0026#39; unit: 0 ipv4_addr: \u0026#39;192.168.1.1/24\u0026#39; ipv6_addr: \u0026#39;1::1/64\u0026#39; descr: \u0026#34;Testing RF\u0026#34; family: inet group: ALL save_cfg: True save_format: set First dictionary from the variables file, device, has the details needed to login to the device. As in my previous posts, I will be using Junos PyEz to interact with the device. Dictionary named configure has the parameters required for configuration change, I will go through what exactly will be configured in later sections.\nResource # By this blog post we know that the Keywords needed in our Test Suite will be defined as a Python Function in Resource file.\nfrom jnpr.junos import Device from jnpr.junos.utils.config import Config import xml.etree.ElementTree as ET def connect_to_device(host, user, pwd, port): dev = Device(host=host, user=user, password=pwd, port=port) dev.open() return dev def teardown(device): device.close() def intf_up_count(device): intf_xml = device.rpc.get_interface_information(terse=True) physical_up_count = intf_xml.xpath(\u0026#34;.//physical-interface[oper-status=\u0026#39;\\nup\\n\u0026#39;]\u0026#34;) logical_count = intf_xml.xpath(\u0026#34;.//physical-interface/logical-interface[oper-status=\u0026#39;\\nup\\n\u0026#39;]\u0026#34;) return len(physical_up_count)+len(logical_count) def ospf_nbr_count(device): ospf_xml = device.rpc.get_ospf_neighbor_information() full_nbr_count = ospf_xml.xpath(\u0026#34;.//ospf-neighbor[ospf-neighbor-state=\u0026#39;Full\u0026#39;]\u0026#34;) return len(full_nbr_count) def bgp_up_count(device): bgp_xml = device.rpc.get_bgp_summary_information() total_peers = bgp_xml.findtext(\u0026#34;.//peer-count\u0026#34;) down_peers = bgp_xml.findtext(\u0026#34;.//down-peer-count\u0026#34;) return int(total_peers)-int(down_peers) def sys_alarm_check(device): alarm_xml = device.rpc.get_system_alarm_information() alarm_count = alarm_xml.findtext(\u0026#34;.//active-alarm-count\u0026#34;) return int(alarm_count) def cfg_back(device, cfg_format): conf_xml = device.rpc.get_config(options={\u0026#39;format\u0026#39;: cfg_format}) conf_str = ET.tostring(conf_xml) conf_list = conf_str.decode(\u0026#39;UTF-8\u0026#39;).splitlines()[1:-1] hostname = device.facts[\u0026#39;hostname\u0026#39;] with open(f\u0026#34;{hostname}_backup\u0026#34;, \u0026#34;w\u0026#34;) as f: for line in conf_list: f.write(f\u0026#34;{line}\\n\u0026#34;) return hostname def configuration(device, config_vars): with Config(device, mode=\u0026#39;private\u0026#39;) as cu: cu.load(template_path=\u0026#39;config.conf\u0026#39;, template_vars=config_vars, merge=True, format=\u0026#39;set\u0026#39;) result = cu.commit() return result As you can see, there are a lot of keywords this time! As mentioned earlier, I\u0026rsquo;m using Junos PyEz here and the RPCs it offers to interact with the device. Although I\u0026rsquo;m not going go over each line of this code, as it is quite straight forward, I would still like to mention couple of them. cfg_back is a function to retrieve the current configuration in given format(json,set,xml) and back it up to a file. I\u0026rsquo;m using the RPC get_config() here, which extracts the configuration in given format but the output of RPC is still in xml. So a couple of lines of code to sanitize the output from device and store it in a file named after the hostname of the Device Under Testing (DUT). Please refer Junos PyEz documentation to know more about retrieving configuration from a device.\nconfiguration function is used to make required configuration changes on the device. Junos PyEz has an utility named Config which I will be using here to make the configuration changes. To generate the required configuration, jinja2 template is used and the required variables are taken from the Variables file. template_path is the location of the jinja2 template and template_vars is the dictionary of variables for the jinja2 template which here comes from Variables file. More information on the Junos PyEz Config utility can be found here\nset interfaces {{ name }} unit {{ unit }} description \u0026#34;{{ descr }}\u0026#34; {% if ipv4_addr %} set interfaces {{ name }} unit {{ unit }} family inet address {{ ipv4_addr }} {% endif %} {% if ipv6_addr %} set interfaces {{ name }} unit {{ unit }} family inet6 address {{ ipv6_addr }} {% endif %} set interfaces {{ name }} apply-groups {{ group }} set groups {{ group }} interfaces \u0026lt;*\u0026gt; mtu 1400 # This is from the yaml file used as Variables file (template_vars). configure: intf1: name: \u0026#39;ge-0/0/4\u0026#39; unit: 0 ipv4_addr: \u0026#39;192.168.1.1/24\u0026#39; ipv6_addr: \u0026#39;1::1/64\u0026#39; descr: \u0026#34;Testing RF\u0026#34; family: inet group: ALL save_cfg: True save_format: set Keywords # Keywords file is a collection of Keywords, having a Keywords file separately rather than defining Keywords in Test Suite itself is quite handy. Same Keywords file can be re-used in multiple Test Suites and any new Keyword would be added here to make it readily available in all the Test Suites using this Keywords file. And since this is a robot file, we can make use of various builtin keywords available in RF.\n*** Keywords *** Interface Up Count [Documentation] Keyword to check and verify number of interfaces that are UP [Arguments] ${device} ${int_up} Intf Up Count ${device} should be equal ${int_up} ${interface.up_count} Ospf Neighbor Count [Documentation] Keyword to check and verify number OSPF neighbors in Full State [Arguments] ${device} ${ospf_full} OSPF Nbr Count ${device} should be equal ${ospf_full} ${ospf.nbr_full} BGP Neighbor Count [Documentation] Keyword to check and verify the number of BGP Peers that are UP [Arguments] ${device} ${bgp_up} BGP Up Count ${device} should be equal ${bgp_up} ${bgp.peers_up} System Alarm Check [Documentation] keyword to check and verify system alarm count [Arguments] ${device} ${sys_alarms} Sys Alarm Check ${device} should be equal ${sys_alarms} ${system_alarms.active_count} Configuring Device [Documentation] keyword to make the required config changes [Arguments] ${device} ${config_vars} ${result} ${diff} Configuration ${device} ${config_vars} should be true ${result} log to console \\nConfiguration applied successfully! log to console \\n~~~~ Config Diff ~~~~\\n${diff}\\n Config Backup [Documentation] keyword to save the config before making changes, format can be set, json, xml. [Arguments] ${device} ${cfg_format} ${filename} Cfg Back ${device} ${cfg_format} log to console \\nBackup Filename: ${filename} Again, quite a few Keywords but if you look closely, they are all similar, so let\u0026rsquo;s go over a couple of them. Interface Up Count as documentation states, is used to check and verify the number of UP interfaces. This Keyword expects one argument, ${device} which will be passed from Test Suite file. ${int_up} is the variable used to hold the output from the Keyword Intf Up Count, which is nothing but a function defined in the Resource file, shown below for quick reference.\ndef intf_up_count(device): intf_xml = device.rpc.get_interface_information(terse=True) physical_up_count = intf_xml.xpath(\u0026#34;.//physical-interface[oper-status=\u0026#39;\\nup\\n\u0026#39;]\u0026#34;) logical_count = intf_xml.xpath(\u0026#34;.//physical-interface/logical-interface[oper-status=\u0026#39;\\nup\\n\u0026#39;]\u0026#34;) return len(physical_up_count)+len(logical_count) Output from the function/keyword is then passed to the builtin keyword should be equal to compare the extracted value with the expected value ${interface_count}, dictionary named interface with the key up_count in the Variables file.\nKeyword Configuration Device is worth taking a look as well, this one expects two arguments ${device} and ${config_vars}. As mentioned earlier, ${config_vars} is a dictionary with variables required by jinja2 template to generate the required configuration. This keyword returns 2 values, one if the configuration was successful or not and two the configuration difference between the running and candidate config.\nTest Suite # Everything comes together now in the Test Suite file, let\u0026rsquo;s break it down and take a look at it in sections.\n*** Settings *** Library functions.py Variables var.yml Suite Setup Test Suite Setup Resource my_keywords.robot Suite Teardown Test Suite Teardown Settings section is used to define the various files required for the Test Suite, new to this Test Suite is Suite Setup. This is used to execute anything before running the Test Cases in the Test Suite, and in this case we will be initiating the connection to the device as a part of Suite Setup. Similarly, we have Suite Teardown which is executed after all the Test Cases are executed.\n*** Keywords *** Test Suite Setup [Documentation] To initialise connection to the device ${conn} Connect To Device ${device.ip} ${device.user} ${device.pwd} ${device.port} Set Suite Variable ${conn} Test Suite Teardown [Documentation] To close the connection to the device gracefully Teardown ${conn} Test Suite Setup as mentioned earlier, is used to initialise a connection to the device, this is done using a keyword (in other words Python function) Connect To Device. ${conn} variable holds the return value from the keyword, which is nothing but the Device Object. Set Suite Variable is used to ensure the variable ${conn} is available throughout the Test Suite. Test Suite Teardown is used to close the connection to the device gracefully.\nContinuing with the Test Suite, we reach the Test Cases section. I have included 3 Test Cases, one to check the network state before change, two to make the configuration change and three to check the network state post change to validate.\n*** Test Cases *** TC - Pre checks before the configuration change \u0026amp; config backup [Documentation] In this testcase various network functions will be checked and matched against a given set ... of ideal values. Test Case would fail if there are any mismatches Sanity Checks ${conn} # Backup the current configuration before change run keyword if ${configure.save_cfg}==True ... run keyword and continue on failure Config Backup ${conn} ${configure.save_format} TC - Configuring the device [Documentation] Configure the device using \u0026#34;config.conf\u0026#34; as the Jinja2 template, with variables from var.yml ${config_vars} set variable ${configure.intf1} run keyword and continue on failure Configuring Device ${conn} ${config_vars} log to console \\nWait for 5sec before starting the Post checks sleep 5 TC - Post checks after the configuration change [Documentation] In this testcase various network functions will be checked and matched against a given set ... of ideal values. Test Case would fail if there are any mismatches Sanity Checks ${conn} Sanity Checks is a keyword which has a bunch of tests to be run as a part of network validation, shown below. run keyword if as it says, would be executed when a given condition is met. In this case, we are checking if variable ${configure.save_cfg} is set to True, this value again comes from the Variables file. When True, Config Backup keyword is executed which as seen before saves the current configuration to a .txt file.\nSanity Checks [Documentation] list of checks to run before and after a configuration change [Arguments] ${conn} log to console \\nVerifying Interface UP count run keyword and continue on failure Interface Up Count ${conn} log to console \\nVerifying OSPF Neighbor UP count run keyword and continue on failure Ospf Neighbor Count ${conn} log to console \\nVerifying BGP Peer UP count run keyword and continue on failure BGP Neighbor Count ${conn} log to console \\nVerifying System Alarms run keyword and continue on failure System Alarm Check ${conn} Going past the documentation part, we see 4 keywords in action, with the majority of them using the builtin run keyword and continue on failure option. This is a handy option when you\u0026rsquo;re running a bunch of tests and you don\u0026rsquo;t want the test execution to stop when there is a failure. With this option, we can ensure that all the tests are run and failures are captured if any.\nTest Execution # With all the required bits in place, let\u0026rsquo;s go ahead with Test Execution.\n(venv) sohanr@sohanr-mbp Robot_practise % robot configure_tc.robot ============================================================================== Configure Tc ============================================================================== TC - Pre checks before the configuration change \u0026amp; config backup ::... Verifying Interface UP count Verifying OSPF Neighbor UP count Verifying BGP Peer UP count Verifying System Alarms . Backup Filename: vMX1 TC - Pre checks before the configuration change \u0026amp; config backup ::... | PASS | ------------------------------------------------------------------------------ TC - Configuring the device :: Configure the device using \u0026#34;config.... . Configuration applied successfully! ~~~~ Config Diff ~~~~ [edit groups ALL interfaces \u0026lt;*\u0026gt;] + mtu 1400; [edit interfaces] + ge-0/0/4 { + apply-groups ALL; + unit 0 { + description \u0026#34;Testing RF\u0026#34;; + family inet { + address 192.168.1.1/24; + } + family inet6 { + address 1::1/64; + } + } + } . Wait for 5sec before starting the Post checks TC - Configuring the device :: Configure the device using \u0026#34;config.... | PASS | ------------------------------------------------------------------------------ TC - Post checks after the configuration change :: In this testcas... Verifying Interface UP count Verifying OSPF Neighbor UP count Verifying BGP Peer UP count Verifying System Alarms TC - Post checks after the configuration change :: In this testcas... | FAIL | 0 != 3 ------------------------------------------------------------------------------ Configure Tc | FAIL | 3 tests, 2 passed, 1 failed ============================================================================== Output: /Users/sohanr/PycharmProjects/Robot_practise/output.xml Log: /Users/sohanr/PycharmProjects/Robot_practise/log.html Report: /Users/sohanr/PycharmProjects/Robot_practise/report.html (venv) sohanr@sohanr-mbp Robot_practise % We see all our 3 Test Cases were executed with Test Case TC - Post checks after the configuration change failing, we will come back to this but before that, let\u0026rsquo;s appreciate the Test Case TC - Configuring the device shall we? We see the TC passed, which means the configuration on the device was successful and we also see a config difference being printed out, neat, right?\nNow coming to the failure, from the execution we see that TestCase TC - Post checks after the configuration change failed, which means some check in Sanity Checks failed. We can also see 0 != 3 is the reason for failure, but it is not clear from here what exactly failed. As I have mentioned in my earlier posts as well, the best thing about using RF for testing, in my opinion, is the logs and reports being available in html, makes it easy to view in a browser. Checking the report generated for our Test Execution, we can clearly see that out of our 3 TCs, 2 Passed and 1 Failed. Now looking at the log, we can see Test Suite Setup and Test Suite Teardown, expanding the sections, we can see what exactly happened.\nLet\u0026rsquo;s take a look at couple of sections together, rest you should be able to explore yourself as it is quite intuitive.\nI have highlighted couple of things to make it easy to look, first one is where we see the device object being returned by Junos PyEz. Second one is where we see the variable which has the device object being set as Suite Variable, documentation makes it clear!\nNow, let\u0026rsquo;s take a look at one of checks being done in TC 1, TC - Pre checks before the configuration change \u0026amp; config backup\nHere we see keyword Sanity Checks getting executed first, within which we have several keywords. Moving to Ospf Neighbor Count keyword, we can see Ospf Nbr Count being called which is defined in our Python file. This keyword or function returns the number of OSPF Neighbors in Full state, which in this is case is 3. Next, we see our verification Should Be Equal, checking if the value we defined is equal to the extracted value.\nMoving to Test Case TC - Post checks after the configuration change, where the failure occurred, let\u0026rsquo;s see if we can make sense of the failure. We can see that failure is seen in Ospf Neighbor Count keyword, we can see Ospf Nbr Count returning 0, which means there are no OSPF neighbors on the device in Full State. Due to this our verification fails as our expected value is 3 but the extracted value is 0! Checking on the device, we can see why.\nWe see all our OSPF neighbors in Exstart state! Looking closely at the configuration changes made.\nOne of our changes included changing the MTU value to 1400 for a group, ALL, which is being applied on the all the interfaces!\nThis may not have been a particularly difficult issue to troubleshoot manually but using RF we were able to test and ensure if our change was successful or not. Let\u0026rsquo;s say you want to add few more checks to your Test Suite, just write Python functions and create keywords in Keywords file, easy! Or you are performing a Software Upgrade and want to run some pre and post checks to ensure nothing is broken, you can write a Test Suite like this to automate the checks and the upgrade itself!\nI know there was a lot to go through in this post, I highly recommend having the code in front of you to help you understand better. I hope I have been clear in explaining everything, if not, please reach out to me with your feedback so that I can do a better job next time.\nReference # Junos PyEz developer guide is a great place to start if you\u0026rsquo;re new to Junos PyEz RobotFramework official user guide is extensive and gives you all the information you need to get started with RF Junos vLABs offers sandboxes with a wide variety of topologies to get a good hands-on experience on Junos. Simple Junos PyEz scripts to start with. "},{"id":1,"href":"/blog/posts/robotframework-2/","title":"Robotframework 2","section":"Posts","content":"It\u0026rsquo;s been a while since my first blog post as I mentioned there, I\u0026rsquo;m at a new job (well it\u0026rsquo;s been 2 months, so \u0026rsquo;newish\u0026rsquo;) and I\u0026rsquo;ve been busy getting to know the job(as with any job, there is a LOT to learn!).\nLearning Robot Framework (RF) has been one of my objectives in these first few months as that is entirely new for me. As I continue to learn and explore RF, I wanted to take some time out to share few things I have learnt. When it comes to network testing, it\u0026rsquo;s not always about testing features, protocols, it also involves testing the hardware components. In this blog post, I want to discuss one such test scenario. This particular Test scenario would be to restart a FPC numerous times and to check and ensure it comes back up to Online state. This is what we call a Negative Trigger Event Testing. Now imagine having to do this manually, needless to say it\u0026rsquo;s a time consuming task, this is where RF comes into play.\nIn this post, I will only explain anything new I\u0026rsquo;m using in RF as compared to my first blog post.\nvaribales.yaml # In this post, I will be using a yaml file to input the variables rather than encoding them directly in the Test Suite file. We define the variables in a yaml file, like shown below, and access them as dictionaries in the Test Suite file.\nVARS: host: 192.168.1.1 #Device under testing fpc: 3 #FPC to reboot With this variable file, we can access the host value as ${VARS.host} and similarly fpc value as ${VARS.fpc}.\nutilities.py # As mentioned in my previous post, any Keywords needed for Test execution will be defined in a Python script as functions. For this Test Case, I have defined two functions, one to check and return the state of the FPC and another one to trigger the FPC restart event, see below.\nfrom jnpr.junos import Device def fpc_restart(host,fpc): \u0026#39;\u0026#39;\u0026#39; Function to restart the FPC \u0026#39;\u0026#39;\u0026#39; dev = Device(host=host, user=\u0026#39;user\u0026#39;, password=\u0026#39;password\u0026#39;) dev.open() dev.rpc.request_chassis_fpc(slot=str(fpc),restart=True) def fpc_state(host,fpc): \u0026#39;\u0026#39;\u0026#39; Function to check the FPC status \u0026#39;\u0026#39;\u0026#39; dev = Device(host=host, user=\u0026#39;user\u0026#39;, password=\u0026#39;password\u0026#39;) dev.open() fpc_state_cli = dev.rpc.get_fpc_information().findtext(f\u0026#34;./fpc[slot=\u0026#39;{fpc}\u0026#39;]/state\u0026#34;) return fpc_state_cli I\u0026rsquo;m using Juniper\u0026rsquo;s PyEz library here as the RPC based options it provides are quite handy than CLI scraping. If you are new to PyEz, you can check out my Github repo where I\u0026rsquo;ve explained how to get started with PyEz and you can also find few basic scripts.\nTest Suite # Now let\u0026rsquo;s look at the Test Suite itself, bit by bit. First, the Settings section. Here we define the Library file, which is where we have our Keywords defined and also Variable file, which is where we have the Variables in yaml.\n*** Settings *** Library utilities.py Variables variables.yaml Next we look at the Test Case\n*** Test Cases *** TC - 1 Restart FPC [Documentation] Test Case to reboot the given FPC FOR ${i} IN RANGE 2 # i = 0, 1 Log To Console \\n~~~ Checking FPC State ~~~ ${fpc_state} = FPC State ${VARS.host} ${VARS.fpc} Run Keyword If \u0026#39;${fpc_state}\u0026#39; == \u0026#39;Online\u0026#39; Log To Console \\n~~~ FPC ${VARS.fpc} is Online\\nProceeding with restart ~~~ ... ELSE Fail \\n~~~ FPC ${VARS.fpc} is ${fpc_state},please recheck ~~~ Run Keyword If \u0026#39;${fpc_state}\u0026#39; == \u0026#39;Online\u0026#39; FPC Restart ${VARS.host} ${VARS.fpc} Sleep 300s Log To Console \\n~~~ Checking FPC State after restart ~~~ ${fpc_state} = FPC State ${VARS.host} ${VARS.fpc} Run Keyword If \u0026#39;${fpc_state}\u0026#39; == \u0026#39;Online\u0026#39; Log To Console \\n~~~ FPC is back Online! ~~~ Log To Console \\n~~~ Iteration ${i} completed ~~~ END There seems to be a LOT going on here but if you look at it closely, there actually isn\u0026rsquo;t. Going past the Documentation field, we see a FOR LOOP. To anyone familiar with programming, this is nothing new, all you need to worry about is the syntax. I always refer to the official user guide to understand the syntax and usage. In our Test Case, number of iterations are 2, which means we will be \u0026lsquo;restarting\u0026rsquo; the given FPC 2 times.\nLog To Console is a builtin Keyword RF offers, which as it says is to print something to the console. Again, I refer to the official documentation for this, here you can explore various builtin Keywords available for you to work with.\nNext, we see our first Keyword (user defined) coming into play.\n${fpc_state} = FPC State ${VARS.host} ${VARS.fpc} Run Keyword If \u0026#39;${fpc_state}\u0026#39; == \u0026#39;Online\u0026#39; Log To Console \\n~~~ FPC ${VARS.fpc} is Online\\nProceeding with restart ~~~ ... ELSE Fail \\n~~~ FPC ${VARS.fpc} is ${fpc_state},please recheck ~~~ Here we are invoking a Keyword FPC State, which is nothing but the fpc_state(host,fpc) function we defined in the utilities.py file, and passing in the variables ${VARS.host} and ${VARS.fpc}. \u0026lsquo;return\u0026rsquo; value from the function/Keyword is then stored in a variable ${fpc_state}.\nThen we see another inbuilt Keyword, Run Keyword If, which as it says, would run a Keyword if a particular condition is met. Condition in our case is if the output returned from the FPC State function is Online or not. If our condition is met (or in other words \u0026lsquo;True\u0026rsquo;) then we execute a Keyword Log To Console, which as explained before would log a message that the FPC we are checking is Online and that we are proceeding with restarting it. But if our condition FAILs, we have a ELSE clause to take care of that. If the ELSE clause is hit, we will first and foremast FAIL our Test Case, that is why we have used another builtin Keyword FAIL and we can also print a message to Console as to why we are failing the Test Case, neat isn\u0026rsquo;t it? Note, if you are wondering what the ... signifies, it is used when you want to continue the code on next line, so as to not over extend the same line.\nContinuing further, we are now invoking our next function/Keyword but only when our condition is met! Condition is still the same one we looked at above!\nRun Keyword If \u0026#39;${fpc_state}\u0026#39; == \u0026#39;Online\u0026#39; FPC Restart ${VARS.host} ${VARS.fpc} Sleep 300s Same 2 variables are passed to FPC Restart Keyword as well. Sleep as you would have guessed it, is a builtin Keyword to, there is no better way to put it, sleep.\nNext section is failry simple as we now check the FPC State again (after 300s remember) to ensure it has come back Online.\nLog To Console \\n~~~ Checking FPC State after restart ~~~ ${fpc_state} = FPC State ${VARS.host} ${VARS.fpc} Run Keyword If \u0026#39;${fpc_state}\u0026#39; == \u0026#39;Online\u0026#39; Log To Console \\n~~~ FPC is back Online! ~~~ Log To Console \\n~~~ Iteration ${i} completed ~~~ The whole process will be repeated as a part of our FOR LOOP, in this case, twice.\nExecution # (personal_env) sohanr@sohanr-mbp:~/envs$ robot fpc_reboot.robot ============================================================================== Fpc Reboot ============================================================================== TC - 1 Restart FPC :: Test Case to reboot the given FPC ~~~ Checking FPC State ~~~ ~~~ FPC 3 is Online Proceeding with restart ~~~ ~~~ Checking FPC State after restart ~~~ ~~~ FPC is back Online! ~~~ ~~~ Iteration 0 completed ~~~ ~~~ Checking FPC State ~~~ ~~~ FPC 3 is Online Proceeding with restart ~~~ ~~~ Checking FPC State after restart ~~~ ~~~ FPC is back Online! ~~~ ~~~ Iteration 1 completed ~~~ TC - 1 Restart FPC :: Test Case to reboot the given FPC | PASS | ------------------------------------------------------------------------------ Fpc Reboot | PASS | 1 test, 1 passed, 0 failed ============================================================================== Output: /homes/sohanr/envs/output.xml Log: /homes/sohanr/envs/log.html Report: /homes/sohanr/envs/report.html (personal_env) sohanr@sohanr-mbp:~/envs$ I\u0026rsquo;m hoping the output is self explaintory, as always with RF, we get the Log and Report in html format which makes viewing it really easy.\nAlso to just show a FAIL scenario, I will provide a FPC slot which is not in use and let\u0026rsquo;s see the output for it.\n(personal_env) sohanr@sohanr-mbp:~/envs$ robot fpc_reboot.robot ============================================================================== Fpc Reboot ============================================================================== TC - 1 Restart FPC :: Test Case to reboot the given FPC ~~~ Checking FPC State ~~~ TC - 1 Restart FPC :: Test Case to reboot the given FPC | FAIL | ~~~ FPC 2 is Empty,please recheck ~~~ ------------------------------------------------------------------------------ Fpc Reboot | FAIL | 1 test, 0 passed, 1 failed ============================================================================== Output: /homes/sohanr/envs/output.xml Log: /homes/sohanr/envs/log.html Report: /homes/sohanr/envs/report.html (personal_env) sohanr@sohanr-mbp:~/envs$ Conclusion # As you might have seen with this post and the previous one, working with Robot Framework is fairly easy as the Keywords are in plain English and they do exactly what they say! I hope this blog post has been informative, as always please feel to reach out to me with any feedback/comments.\n"},{"id":2,"href":"/blog/posts/robotframework-1/","title":"Robotframework-1","section":"Posts","content":"In my new job role as a Test Engineer, knowing how to use Robot Framework for Automating Test Cases is crucial, to save time and to make testing more fun! As I\u0026rsquo;m going through this learning journey, I wanted to blog about it for anyone who is looking to start this journey and also to help me understand things in a better way.\nThere are plenty of good resources out there which explains the Robot Framework and it\u0026rsquo;s components. Best place to start would be the Robot Framework Documentation, which shows some interactive examples and very clear explaination. During my learning what I have come to realise is, there are lot of resources around Robot Framework used for Application Testing but there are not a lot of resources focused on Network Testing(or maybe I haven\u0026rsquo;t been thorough with my search!). That\u0026rsquo;s also one of the reaons for starting this blog, to give a Network Engineer\u0026rsquo;s perspective on Robot Framework and use the examples around networking to help us understand this better.\nSoftware Version Check # For my first example, I wanted to create a Test Case to get the Junos Software Version from a device and compare it with an expected SW version.\nFirst component of our task would be to construct a Python code to get the SW version from a device. I\u0026rsquo;m using Juniper\u0026rsquo;s PyEz Library to get this done. As you can see, it is a very simple script to gather facts and then from the output dictionary filtering out just the value of version using the key named version. If you have gone through the Robot Framework documentation, you would know that it is a Keyword driven framework. And in our case, we define the Keyword using a Python function. That\u0026rsquo;s why you are seeing a function check_version defined in the script which returns the Software Version.\nfrom jnpr.junos import Device def check_version(host): dev = Device(host=host, user=\u0026#39;robot\u0026#39;, password=\u0026#39;Junos12345\u0026#39;) dev.open() return dev.facts[\u0026#39;version\u0026#39;] Second component would be constructing the Robot File (also called Test Suite) with our Test Case. *** Settings *** Library pyez_version.py *** Variables *** ${host} = 10.10.10.11 ${expected_version} = 17.1R1.8 *** Test Cases *** TestCase1 [Documentation] Checking if the SW version matches the requirement ${version_output} = Check Version ${host} Should be equal ${version_output} ${expected_version} SW version doesn\u0026#39;t match the requirement Let\u0026rsquo;s look at some of the components of our Test Suite.\nIn the Settings section, we import the Library, which in our case is the Python script with the function defined to fetch the SW version.\n*** Settings *** Library pyez_version.py Next, we have the Variables section, which as it says is where you\u0026rsquo;d define the Variables. There are multiple ways of defining Variables, we can do it as I have shown below or pass in a list, dictionary etc. host Variable here has the IP address of the device we need to connect, which would be sent as an input to the Python script. expected_version is the Variable used to enter the SW version we wish to test/match on the device.\n*** Variables *** ${host} = 10.10.10.11 ${expected_version} = 17.1R1.8 Now the Test Cases section. Documentation Keyword let\u0026rsquo;s us provide a description for our Test Case.\nThen we see a version_output Variable, which stores the output returned by the Keyword Check Version. This Keyword is nothing but the function we defined in our Python script, just replace underscore with a space and if you look closely, it is case insensitive. After the Keyword, followed by a cell seperator(4 spaces), we provide the input Varibale for our function, which in this case is the IP address of the Host.\nNext we see what is called a built-in Keyword, these come as a part of Robot Framework and doesn\u0026rsquo;t require any Library imports. Built-in Keyword here Should be equal compares two values and the Test Case is determined as PASS if they match and FAIL if they don\u0026rsquo;t. We mention the two values to be compared seperated by a cell seperator. And to customize a message in case of FAIL, we can define a message SW version doesn\u0026rsquo;t match the requirement, which would be displayed when the Test Case FAILs.\n*** Test Cases *** TestCase1 [Documentation] Checking if the SW version matches the requirement ${version_output} = Check Version ${host} Should be equal ${version_output} ${expected_version} SW version doesn\u0026#39;t match the requirement With our required components in place, let\u0026rsquo;s execute the Test Case and see the results.\nPS C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\u0026gt; robot pyez_version.robot ============================================================================== Pyez Version ============================================================================== TestCase1 :: Checking if the SW version matches the requirement | PASS | ------------------------------------------------------------------------------ Pyez Version | PASS | 1 test, 1 passed, 0 failed ============================================================================== Output: C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\\output.xml Log: C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\\log.html Report: C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\\report.html PS C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\u0026gt; Our Test Case Passed! Now, let\u0026rsquo;s change the expected SW Version and see if Robot can detect it and fail our Test Case.\nPS C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\u0026gt;robot pyez_version.robot ============================================================================== Pyez Version ============================================================================== TestCase1 :: Checking if the SW version matches the requirement | FAIL | SW version doesn\u0026#39;t match the requirement: 17.1R1.8 != 16.1R1.8 ------------------------------------------------------------------------------ Pyez Version | FAIL | 1 test, 0 passed, 1 failed ============================================================================== Output: C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\\output.xml Log: C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\\log.html Report: C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\\report.html PS C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\u0026gt; Now our Test Case Failed! And we can clearly see that the expected SW version we passed, 16.1R1.8, did not match the extracted SW version, 17.1R1.8!\nRobot also let\u0026rsquo;s us pass the Variable from the command line, i.e. instead of hardcoding the expected_version varibale in the Test Suite, we can input this from the command line. Let\u0026rsquo;s see how to do it, updated Test Suite looks like below, only change is that I have commeneted the expected_variable under the Variables section.\n*** Settings *** Library pyez_version.py *** Variables *** ${host} = 10.10.10.11 #${expected_version} = 16.1R1.8 *** Test Cases *** TestCase1 [Documentation] Checking if the SW version matches the requirement ${version_output} = Check Version ${host} Should be equal ${version_output} ${expected_version} SW version doesn\u0026#39;t match the requirement To enter the Variable from command line, we use -v key, as shown below.\nPS C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\u0026gt;robot -v expected_version:16.1R1.8 pyez_version.robot ============================================================================== Pyez Version ============================================================================== TestCase1 :: Checking if the SW version matches the requirement | FAIL | SW version doesn\u0026#39;t match the requirement: 17.1R1.8 != 16.1R1.8 ------------------------------------------------------------------------------ Pyez Version | FAIL | 1 test, 0 passed, 1 failed ============================================================================== Output: C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\\output.xml Log: C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\\log.html Report: C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\\report.html PS C:\\Users\\User\\PycharmProjects\\Robotframework\\Junos\u0026gt; Another great feature Robot Framework offers is, Test reports and logs are generated in html which makes reading it very easy using a web browser. Path to the Log and Report is printed out to the Console as you can see in the above output.\nReport for our Test Suite is shown below We can toggle to the Log file by clicking on LOG displayed on the top right corner, LOG file our Test Case is shown below And with that we have completed our first Testing using Robot Framework! Hopefully, you and I can now explore more and start Testing complex network related things.\nAs this is my first take at blogging, I\u0026rsquo;d really appreciate your feedback so that I can keep getting better at this!\nDependencies # You need to have Robot Framework installed and any other dependencies based on your Python script. In this example, that would be PyEz.\npython -m pip install robotframework junos-eznc "}]